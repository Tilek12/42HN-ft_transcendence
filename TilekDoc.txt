=========================================================
		Tournament Implementation Issues Report
=========================================================

---------------------------------------------------------
1. WebSocket Message Schema Inconsistencies
---------------------------------------------------------

Problem: Local and online tournaments use different message structures,
causing confusion and potential failures.

Evidence:

Local tournaments send: { p1: {id, name}, p2: {id, name} }
Online tournaments send: { player1: id, player2: id }
Impact: Frontend can't reliably parse messages from both modes.

Fix: Define strict TypeScript interfaces for all message types and standardize schemas.

---------------------------------------------------------
2. Player Readiness Signaling Issues
---------------------------------------------------------

Problem: The complex polling-based readiness system in tournament-manager.ts is unreliable.

Evidence: waitForAllPlayersReady() and waitForPlayerSockets() use 100ms polling with timeouts
that may miss signals or timeout prematurely.

Impact: Tournament matches may fail to start or start with missing players.

Fix: Replace polling with promise-based event signaling.

---------------------------------------------------------
3. Tournament State Broadcasting Problems
---------------------------------------------------------

Problem: Tournament updates aren't consistently sent to all relevant clients.

Evidence: broadcastTournamentUpdate() only sends to participants, ignoring spectators and
potential race conditions.

Impact: UI may not update properly for all users.

Fix: Ensure all connected tournament clients receive state updates.

---------------------------------------------------------
4. Local Tournament Control Socket Issues
---------------------------------------------------------

Problem: Local tournaments use a single control socket but message handling is inconsistent.

Evidence: Frontend sends different message structures for local vs online, but backend expects
unified handling.

Impact: Local tournament controls may not work properly.

Fix: Unify message handling logic for both modes.

---------------------------------------------------------
5. Database Relationship Issues
---------------------------------------------------------

Problem: Tournament matches aren't properly linked to tournaments in the database.

Evidence: linkMatchToTournament() exists but is commented out in matchmaking.ts.

Impact: Tournament history and statistics are incomplete.

Fix: Properly link matches to tournaments and ensure data consistency.

---------------------------------------------------------
6. Frontend State Management Complexity
---------------------------------------------------------

Problem: Multiple global variables in tournament.ts lead to inconsistent state.

Evidence: Variables like currentTournamentId, isLocalTournament, currentMatch can become desynchronized.

Impact: UI bugs and race conditions.

Fix: Implement proper state management (e.g., using a store pattern).

---------------------------------------------------------
7. Error Handling and Recovery Deficiencies
---------------------------------------------------------

Problem: Poor error handling when WebSocket connections fail.

Evidence: Many handlers lack recovery logic, leaving tournaments in broken states.

Impact: System becomes unstable after network issues.

Fix: Add comprehensive error handling and automatic recovery.

---------------------------------------------------------
8. Resource Cleanup Issues
---------------------------------------------------------

Problem: Tournament resources aren't properly cleaned up.

Evidence: quitTournament() removes participants but doesn't handle ongoing games or sockets properly.

Impact: Memory leaks and zombie connections.

Fix: Implement proper cleanup in all exit paths.

---------------------------------------------------------
9. Concurrency and Race Conditions
---------------------------------------------------------

Problem: No synchronization for concurrent tournament state updates.

Evidence: Multiple operations can modify tournament state simultaneously without locks.

Impact: Data corruption and inconsistent behavior.

Fix: Add proper synchronization mechanisms.

---------------------------------------------------------
10. Message Type Safety Issues
---------------------------------------------------------

Problem: Loose typing allows invalid messages to pass through.

Evidence: Many message handlers use any types and don't validate structure.

Impact: Runtime errors from malformed messages.

Fix: Define strict interfaces and validate all messages.




=========================================================================================
=========================================================================================
=========================================================================================
=========================================================================================




=========================================================
Tournament System Issues and Graceful Solutions
=========================================================

Based on the code analysis (focusing on tournament-manager.ts, tournament-ws.ts, game-ws.ts, and
related types/schemas), here are the identified issues in the tournament system, along with proper
solutions following best practices (e.g., event-driven architecture, strict typing, atomic operations,
comprehensive error handling). Solutions prioritize maintainability, scalability, and reliability
without over-engineering. Each includes exact steps for fixes.

---------------------------------------------------------
1. WebSocket Message Schema Inconsistencies
---------------------------------------------------------

Issue: Local tournaments send { p1: {id, name}, p2: {id, name} },
online send { player1: id, player2: id }. Frontend can't parse reliably.
Unified handling expected but not enforced.

Solution: Define strict TypeScript interfaces for all WebSocket messages
(e.g., in WebsocketSchemas.ts). Use Zod or similar for runtime validation.
Standardize on consistent structures (e.g., always use participant objects with id/name).
Add a message type discriminator.

Exact Steps:

In WebsocketSchemas.ts, add new schemas: TournamentMatchStartSchema with properties like
type: 'matchStart', tournamentId, matchId, participants: [{id, name}, {id, name}].
In tournament-ws.ts and tournament-manager.ts, update message sending to use
the standardized schema (e.g., always send participant objects).
In frontend ws-manager.ts, add validation/parsing logic to handle the unified format.
Test local vs. online modes to ensure consistent parsing.

---------------------------------------------------------
2. Player Readiness Signaling Issues
---------------------------------------------------------

Issue: Polling-based readiness (100ms checks with 15s timeout) is unreliable,
may miss signals or timeout prematurely. waitForAllPlayersReady() and waitForPlayerSockets()
use inefficient polling.

Solution: Replace polling with event-driven signaling using promises/events.
Use a Map for readiness states with timeouts as fallbacks. Implement a readiness manager
class for better encapsulation.

Exact Steps:

In tournament-manager.ts, create a ReadinessManager class with methods like
signalReady(playerId, matchId), waitForReadiness(matchId, expectedPlayers) returning a Promise.
Replace waitForAllPlayersReady() with
await readinessManager.waitForReadiness(readyKey, expectedPlayers).
In tournament-ws.ts, call tournamentManager.signalReady(userId, data.matchId) on
'playerReady' message.
Add timeout logic in ReadinessManager to reject promises after 15s, triggering fallback start.
Remove polling loops; use async/await for sequential flow.

---------------------------------------------------------
3. Tournament State Broadcasting Problems
---------------------------------------------------------

Issue: broadcastTournamentUpdate() sends only to participants, ignoring spectators.
Race conditions possible if state updates concurrently.

Solution: Broadcast to all connected tournament clients (participants + spectators).
Use a separate spectator list or query all online users. Ensure atomic updates with locks or queues.

Exact Steps:

In tournament-manager.ts, modify broadcastTournamentUpdate() to iterate over all online users
(via userManager.getOnlineUsers()) and send to their tournamentSocket if open.
Add a spectators array to TournamentState for optional tracking.
Use a queue (e.g., async queue library) for state updates to prevent races: enqueue updates and
process sequentially.
In presence-ws.ts, ensure sendTournamentUpdate() also broadcasts to spectators if needed.

---------------------------------------------------------
4. Local Tournament Control Socket Issues
---------------------------------------------------------

Issue: Local tournaments use a single control socket, but message handling is inconsistent
(different structures for local vs. online).

Solution: Treat local tournaments as a special case with unified message handling.
Use the same schemas but add a mode field. Ensure the control socket is properly managed as
a participant socket.

Exact Steps:

In tournament-manager.ts, when creating local tournaments, set the control socket as
a "virtual participant" in participants.
Update message sending in startOneMatch() to always use the standardized schema, with
mode: 'local' flag.
In tournament-ws.ts, handle local mode by routing messages to the control socket appropriately.
Test local tournament creation/joining to ensure messages are consistent.

---------------------------------------------------------
5. Database Relationship Issues
---------------------------------------------------------

Issue: linkMatchToTournament() is commented out in matchmaking.ts.
Tournament matches aren't linked to tournaments in DB, leading to incomplete history/stats.

Solution: Properly link matches to tournaments using foreign keys. Ensure atomic DB operations
with transactions. Update createMatch() to include tournament ID.

Exact Steps:

In database/client.ts, ensure matches table has tournament_id foreign key to tournaments(id).
In database/match.ts, update createMatch() to accept and insert tournamentId.
In matchmaking.ts, uncomment and fix linkMatchToTournament() to insert into
tournament_matches table.
In tournament-manager.ts, after match creation, call createMatch() with tournamentId and
link via linkMatchToTournament().
Use DB transactions for match creation and linking to ensure consistency.

---------------------------------------------------------
6. Frontend State Management Complexity
---------------------------------------------------------

Issue: Global variables (currentTournamentId, isLocalTournament, etc.) in tournament.ts
become desynchronized, leading to bugs.

Solution: Implement a state management pattern (e.g., simple store with reactive updates).
Use a class or context for tournament state.

Exact Steps:

In frontend/pages/tournament.ts, create a TournamentStore class with properties like
currentTournament, isLocal, and methods to update state.
Replace global variables with store instance.
Use event listeners or reactive bindings to update UI on state changes.
Add validation in store setters to prevent invalid states.

---------------------------------------------------------
7. Error Handling and Recovery Deficiencies
---------------------------------------------------------

Issue: Poor error handling; handlers lack recovery logic, leaving tournaments in broken
states after WebSocket failures.

Solution: Add try-catch with recovery (e.g., retry connections, rollback state).
Use centralized error logging. Implement graceful degradation.

Exact Steps:

In tournament-manager.ts and tournament-ws.ts, wrap critical operations (e.g., startTournament(),
message handling) in try-catch.
On errors, log details and attempt recovery (e.g., restart match, notify clients).
Add a recoverTournament(tournamentId) method to reset state and reconnect players.
In WebSocket close handlers, trigger recovery if tournament is active.

---------------------------------------------------------
8. Resource Cleanup Issues
---------------------------------------------------------

Issue: quitTournament() removes participants but doesn't handle ongoing games or
sockets properly.
Memory leaks from zombie connections.

Solution: Implement comprehensive cleanup in all exit paths. Use RAII-like patterns or
cleanup hooks.

Exact Steps:

In tournament-manager.ts, enhance quitTournament() to: stop ongoing matches,
close all participant sockets, remove from tournaments map.
Add a cleanupTournament(tournamentId) method called on finish or error.
In user-manager.ts, ensure socket removal triggers tournament cleanup.
Use finally blocks in async operations for guaranteed cleanup.

---------------------------------------------------------
9. Concurrency and Race Conditions
---------------------------------------------------------

Issue: No synchronization; multiple operations modify TournamentState simultaneously,
causing corruption.

Solution: Use locks (e.g., async-mutex) for state modifications. Make operations atomic.

Exact Steps:

Install async-mutex and import Mutex.
In tournament-manager.ts, add a Mutex instance per tournament.
Wrap state-modifying methods (e.g., joinTournament(), onMatchEnd()) with
await mutex.acquire(); try { ... } finally { mutex.release(); }.
Test concurrent joins/starts to ensure no races.

---------------------------------------------------------
10. Message Type Safety Issues
---------------------------------------------------------

Issue: Loose typing (any types) allows invalid messages, leading to runtime errors.

Solution: Use strict interfaces and validation. Leverage TypeScript and schema validation.

Exact Steps:

In WebsocketSchemas.ts, define schemas for all tournament messages
(e.g., PlayerReadySchema, QuitTournamentSchema).
In tournament-ws.ts, validate incoming messages against schemas before processing.
Replace any with typed interfaces in handlers.
Add unit tests for message validation.
These solutions maintain the existing architecture while improving robustness.
Implement incrementally, testing each fix. If issues persist, consider refactoring to
a more event-sourced model for tournaments.
